# Textures in Three.js

Textures are images that cover the surface of geometries.  
There are many types, each with different effects.

We are going to discover the most used types with the **door textures by Josao Paulo**.

---

## Types of Textures

### Color Texture
- Most simple one
- Applied on geometry

### Alpha Texture
- Grayscale image
- White = visible
- Black = not visible

### Height (or Displacement) Texture
- Grayscale image
- Moves the vertices to create relief
- Needs enough subdivisions

### Normal Texture
- Adds details
- Doesn't need subdivision
- Vertices won't move
- Tricks the light about face orientation
- Better performance than height texture with many subdivisions

### Ambient Occlusion Texture
- Grayscale image
- Adds fake shadows in crevices
- Not physically accurate
- Helps create contrast and show details

### Metalness Texture
- Grayscale image
- White = metallic
- Black = non-metallic
- Mostly for reflection

### Roughness Texture
- Grayscale image
- Used with metalness
- White = rough
- Black = smooth
- Mostly for light dissipation

---

There are many other types, but these are the main ones and we will focus on them.

---

## PBR Principles

These textures (especially metalness and roughness) follow the **PBR principles**:

- **PBR**: Physically Based Rendering
- Techniques that follow real-life directions for realistic results
- Becoming the standard for realistic renders
- Many software, engines, and libraries use it

---

## Using Images as Textures

There are two ways to use images as textures:

### 1. Load the image and save it into a texture

```js
let image = new Image();
const texture = new THREE.Texture(image);
image.onload = () => {
    texture.needsUpdate = true;
};
image.src = colorImage;
```

### 2. Use the TextureLoader

```js
let textureLoader = new THREE.TextureLoader();
let texture = textureLoader.load("/src/assets/textures/color.jpg");
```

You can pass three functions after the path in the `load` method:

- **load**: when the image loads successfully
- **progress**: when loading is progressing
- **error**: if something goes wrong

```js
let textureLoader = new THREE.TextureLoader();
let texture = textureLoader.load(
    "/src/assets/textures/color.jpg",
    () => { console.log("loading"); },
    () => { console.log("Progress"); },
    () => { console.log("error"); }
);
```

But in real life, we usually just provide the image path.

---

## Loading Manager

We can use the `LoadingManager` to handle global loading events.  
It's useful to know the overall loading progress or when everything is loaded.

Create an instance of the `LoadingManager` class and pass it to the `TextureLoader`:

```js
let loadingManager = new THREE.LoadingManager();

loadingManager.onStart = () => {
    console.log("Loading started");
};
loadingManager.onLoad = () => {
    console.log("Loading finished");
};
loadingManager.onProgress = () => {
    console.log("Loading Progressing");
};
loadingManager.onError = () => {
    console.log("Error occurred");
};

let textureLoader = new THREE.TextureLoader(loadingManager);
let texture = textureLoader.load("/src/assets/textures/color.jpg");
```

---

## UV Unwrapping

If we replace `boxGeometry` with other geometries (sphere, cone, torus, tube, etc.),  
the texture may stretch or squeeze to cover the geometry.  
This is called **UV unwrapping**—like unwrapping origami or a candy wrap to make it flat.

Each vertex will have 2D coordinates on a flat plane (usually a square).  
You can see those UV coordinates in `geometry.attributes.uv`:

```js
console.log(geometry.attributes.uv);
```

- UV coordinates are generated by Three.js.
- If you create your own geometry, you must specify the UV coordinates.
- If you use 3D software, you'll also need to do UV unwrapping.

---

## Transforming Textures

You can **repeat** a texture using the `repeat` property (a `Vector2` with `x` and `y`):

```js
let texture = textureLoader.load("/src/assets/textures/color.jpg");

// Repeat texture
texture.repeat.x = 2;
texture.repeat.y = 3;
```

By default, the texture doesn't repeat and the last pixel gets stretched.  
Change this with `THREE.RepeatWrapping` on the `wrapS` and `wrapT` properties:

```js
texture.repeat.x = 2;
texture.repeat.y = 3;
texture.wrapS = THREE.RepeatWrapping;
texture.wrapT = THREE.RepeatWrapping;
```

You can also **offset** the texture:

```js
texture.offset.x = 0.5;
texture.offset.y = 0.5;
```

And **rotate** the texture, setting the center property:

```js
texture.rotation = Math.PI / 4;
texture.center.x = 0.5;
texture.center.y = 0.5;
```

---

## Filtering and Mipmapping

If you look at the cube's top face while it's almost hidden, you'll see a blurry texture.  
This is due to **filtering and mipmapping**.

**Mipmapping** creates half-sized versions of a texture repeatedly until 1x1.  
All variations are sent to the GPU, which chooses the most appropriate version.

Three.js and the GPU handle this, but you can choose different algorithms.

### Filter Algorithms

#### Minification Filter

Happens when the texture pixels are smaller than the render pixels (texture is too big for the surface).

Change the minification filter with the `minFilter` property (6 values):

- `THREE.NearestFilter`
- `THREE.LinearFilter`
- `THREE.NearestMipmapNearestFilter`
- `THREE.NearestMipmapLinearFilter`
- `THREE.LinearMipmapNearestFilter`
- `THREE.LinearMipmapLinearFilter` (default)

Example:

```js
texture.minFilter = THREE.NearestFilter;
```

---

## Texture Format and Optimization

When creating a texture, keep in mind these three crucial elements:

- The height
- The size (resolution)
- The data

### The Weight

Users must download the textures—choose the right file type:

- `.jpg`: lossy compression, usually lighter
- `.png`: lossless compression, usually heavier

Use compression tools like [TinyPNG](https://tinypng.com).

### The Size

Each pixel must be stored on the GPU, regardless of image weight.  
GPU has storage limitations, and mipmapping increases the number of pixels to store.  
Reduce image size as much as possible.

Mipmapping produces half-sized versions until 1x1.  
Texture width and height must be powers of 2:

- `512 x 512`
- `1024 x 1024`
- `521 x 2048`

### The Data

Textures support transparency, but `.jpg` does not.  
For color and alpha in one texture, use `.png`.

For normal textures, use exact values—avoid lossy compression, use `.png`.

Sometimes, you can combine different data into one texture using red, green, blue, and alpha channels.

**Always make sure you have rights to use any image not for personal use.**  
You can create your own textures using photos, 2D software like Photoshop, or procedural textures with Substance Designer.

---